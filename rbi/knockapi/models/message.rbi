# typed: strong

module Knockapi
  module Models
    class Message < Knockapi::Internal::Type::BaseModel
      OrHash =
        T.type_alias { T.any(Knockapi::Message, Knockapi::Internal::AnyHash) }

      # The unique identifier for the message.
      sig { returns(String) }
      attr_accessor :id

      # The typename of the schema.
      sig { returns(String) }
      attr_accessor :_typename

      # Deprecated, use channel.id instead.
      sig { returns(String) }
      attr_accessor :channel_id

      # A list of engagement statuses.
      sig do
        returns(T::Array[Knockapi::Message::EngagementStatus::TaggedSymbol])
      end
      attr_accessor :engagement_statuses

      # Timestamp when the resource was created.
      sig { returns(Time) }
      attr_accessor :inserted_at

      # A reference to a recipient, either a user identifier (string) or an object
      # reference (ID, collection).
      sig { returns(Knockapi::RecipientReference::Variants) }
      attr_accessor :recipient

      # The workflow or guide that triggered the message.
      sig { returns(Knockapi::Message::Source) }
      attr_reader :source

      sig { params(source: Knockapi::Message::Source::OrHash).void }
      attr_writer :source

      # The message delivery status.
      sig { returns(Knockapi::Message::Status::TaggedSymbol) }
      attr_accessor :status

      # The timestamp when the resource was last updated.
      sig { returns(Time) }
      attr_accessor :updated_at

      # One or more actors that are associated with this message. Note: this is a list
      # that can contain up to 10 actors if the message is produced from a
      # [batch](/designing-workflows/batch-function).
      sig do
        returns(T.nilable(T::Array[Knockapi::RecipientReference::Variants]))
      end
      attr_reader :actors

      sig do
        params(
          actors:
            T::Array[
              T.any(
                String,
                Knockapi::RecipientReference::ObjectReference::OrHash
              )
            ]
        ).void
      end
      attr_writer :actors

      # Timestamp when the message was archived.
      sig { returns(T.nilable(Time)) }
      attr_accessor :archived_at

      # A configured channel, which is a way to route messages to a provider.
      sig { returns(T.nilable(Knockapi::Message::Channel)) }
      attr_reader :channel

      sig { params(channel: Knockapi::Message::Channel::OrHash).void }
      attr_writer :channel

      # Timestamp when the message was clicked.
      sig { returns(T.nilable(Time)) }
      attr_accessor :clicked_at

      # Data associated with the message’s workflow run. Includes the workflow trigger
      # request’s `data` payload merged with any additional data returned by a
      # [fetch function](/designing-workflows/fetch-function). For messages produced
      # after a [batch step](/designing-workflows/batch-function), includes the payload
      # `data` from the most-recent trigger request (the final `activity` in the batch).
      sig { returns(T.nilable(T::Hash[Symbol, T.anything])) }
      attr_accessor :data

      # Timestamp when the message was interacted with.
      sig { returns(T.nilable(Time)) }
      attr_accessor :interacted_at

      # Timestamp when a link in the message was clicked.
      sig { returns(T.nilable(Time)) }
      attr_accessor :link_clicked_at

      # The metadata associated with the message.
      sig { returns(T.nilable(T::Hash[Symbol, T.anything])) }
      attr_accessor :metadata

      # Timestamp when the message was read.
      sig { returns(T.nilable(Time)) }
      attr_accessor :read_at

      # Timestamp when the message was scheduled to be sent.
      sig { returns(T.nilable(Time)) }
      attr_accessor :scheduled_at

      # Timestamp when the message was seen.
      sig { returns(T.nilable(Time)) }
      attr_accessor :seen_at

      # The ID of the `tenant` associated with the message. Only present when a `tenant`
      # is provided on a workflow trigger request.
      sig { returns(T.nilable(String)) }
      attr_accessor :tenant

      # The key of the workflow that generated the message.
      sig { returns(T.nilable(String)) }
      attr_accessor :workflow

      # Represents a single message that was generated by a workflow for a given
      # channel.
      sig do
        params(
          id: String,
          _typename: String,
          channel_id: String,
          engagement_statuses:
            T::Array[Knockapi::Message::EngagementStatus::OrSymbol],
          inserted_at: Time,
          recipient:
            T.any(
              String,
              Knockapi::RecipientReference::ObjectReference::OrHash
            ),
          source: Knockapi::Message::Source::OrHash,
          status: Knockapi::Message::Status::OrSymbol,
          updated_at: Time,
          actors:
            T::Array[
              T.any(
                String,
                Knockapi::RecipientReference::ObjectReference::OrHash
              )
            ],
          archived_at: T.nilable(Time),
          channel: Knockapi::Message::Channel::OrHash,
          clicked_at: T.nilable(Time),
          data: T.nilable(T::Hash[Symbol, T.anything]),
          interacted_at: T.nilable(Time),
          link_clicked_at: T.nilable(Time),
          metadata: T.nilable(T::Hash[Symbol, T.anything]),
          read_at: T.nilable(Time),
          scheduled_at: T.nilable(Time),
          seen_at: T.nilable(Time),
          tenant: T.nilable(String),
          workflow: T.nilable(String)
        ).returns(T.attached_class)
      end
      def self.new(
        # The unique identifier for the message.
        id:,
        # The typename of the schema.
        _typename:,
        # Deprecated, use channel.id instead.
        channel_id:,
        # A list of engagement statuses.
        engagement_statuses:,
        # Timestamp when the resource was created.
        inserted_at:,
        # A reference to a recipient, either a user identifier (string) or an object
        # reference (ID, collection).
        recipient:,
        # The workflow or guide that triggered the message.
        source:,
        # The message delivery status.
        status:,
        # The timestamp when the resource was last updated.
        updated_at:,
        # One or more actors that are associated with this message. Note: this is a list
        # that can contain up to 10 actors if the message is produced from a
        # [batch](/designing-workflows/batch-function).
        actors: nil,
        # Timestamp when the message was archived.
        archived_at: nil,
        # A configured channel, which is a way to route messages to a provider.
        channel: nil,
        # Timestamp when the message was clicked.
        clicked_at: nil,
        # Data associated with the message’s workflow run. Includes the workflow trigger
        # request’s `data` payload merged with any additional data returned by a
        # [fetch function](/designing-workflows/fetch-function). For messages produced
        # after a [batch step](/designing-workflows/batch-function), includes the payload
        # `data` from the most-recent trigger request (the final `activity` in the batch).
        data: nil,
        # Timestamp when the message was interacted with.
        interacted_at: nil,
        # Timestamp when a link in the message was clicked.
        link_clicked_at: nil,
        # The metadata associated with the message.
        metadata: nil,
        # Timestamp when the message was read.
        read_at: nil,
        # Timestamp when the message was scheduled to be sent.
        scheduled_at: nil,
        # Timestamp when the message was seen.
        seen_at: nil,
        # The ID of the `tenant` associated with the message. Only present when a `tenant`
        # is provided on a workflow trigger request.
        tenant: nil,
        # The key of the workflow that generated the message.
        workflow: nil
      )
      end

      sig do
        override.returns(
          {
            id: String,
            _typename: String,
            channel_id: String,
            engagement_statuses:
              T::Array[Knockapi::Message::EngagementStatus::TaggedSymbol],
            inserted_at: Time,
            recipient: Knockapi::RecipientReference::Variants,
            source: Knockapi::Message::Source,
            status: Knockapi::Message::Status::TaggedSymbol,
            updated_at: Time,
            actors: T::Array[Knockapi::RecipientReference::Variants],
            archived_at: T.nilable(Time),
            channel: Knockapi::Message::Channel,
            clicked_at: T.nilable(Time),
            data: T.nilable(T::Hash[Symbol, T.anything]),
            interacted_at: T.nilable(Time),
            link_clicked_at: T.nilable(Time),
            metadata: T.nilable(T::Hash[Symbol, T.anything]),
            read_at: T.nilable(Time),
            scheduled_at: T.nilable(Time),
            seen_at: T.nilable(Time),
            tenant: T.nilable(String),
            workflow: T.nilable(String)
          }
        )
      end
      def to_hash
      end

      # An engagement status for a message. Can be one of: read, seen, interacted,
      # link_clicked, archived.
      module EngagementStatus
        extend Knockapi::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias { T.all(Symbol, Knockapi::Message::EngagementStatus) }
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        SEEN = T.let(:seen, Knockapi::Message::EngagementStatus::TaggedSymbol)
        READ = T.let(:read, Knockapi::Message::EngagementStatus::TaggedSymbol)
        INTERACTED =
          T.let(:interacted, Knockapi::Message::EngagementStatus::TaggedSymbol)
        LINK_CLICKED =
          T.let(
            :link_clicked,
            Knockapi::Message::EngagementStatus::TaggedSymbol
          )
        ARCHIVED =
          T.let(:archived, Knockapi::Message::EngagementStatus::TaggedSymbol)

        sig do
          override.returns(
            T::Array[Knockapi::Message::EngagementStatus::TaggedSymbol]
          )
        end
        def self.values
        end
      end

      class Source < Knockapi::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(Knockapi::Message::Source, Knockapi::Internal::AnyHash)
          end

        sig { returns(String) }
        attr_accessor :_typename

        # The categories associated with the message.
        sig { returns(T::Array[String]) }
        attr_accessor :categories

        # The key of the workflow or guide that triggered the message.
        sig { returns(String) }
        attr_accessor :key

        # The ID of the version of the workflow or guide that triggered the message.
        sig { returns(String) }
        attr_accessor :version_id

        # The step reference for the step in the workflow that generated the message.
        sig { returns(T.nilable(String)) }
        attr_accessor :step_ref

        # Whether this message was generated from a workflow, broadcast, or guide.
        sig do
          returns(T.nilable(Knockapi::Message::Source::Type::TaggedSymbol))
        end
        attr_reader :type

        sig { params(type: Knockapi::Message::Source::Type::OrSymbol).void }
        attr_writer :type

        # The workflow or guide that triggered the message.
        sig do
          params(
            _typename: String,
            categories: T::Array[String],
            key: String,
            version_id: String,
            step_ref: T.nilable(String),
            type: Knockapi::Message::Source::Type::OrSymbol
          ).returns(T.attached_class)
        end
        def self.new(
          _typename:,
          # The categories associated with the message.
          categories:,
          # The key of the workflow or guide that triggered the message.
          key:,
          # The ID of the version of the workflow or guide that triggered the message.
          version_id:,
          # The step reference for the step in the workflow that generated the message.
          step_ref: nil,
          # Whether this message was generated from a workflow, broadcast, or guide.
          type: nil
        )
        end

        sig do
          override.returns(
            {
              _typename: String,
              categories: T::Array[String],
              key: String,
              version_id: String,
              step_ref: T.nilable(String),
              type: Knockapi::Message::Source::Type::TaggedSymbol
            }
          )
        end
        def to_hash
        end

        # Whether this message was generated from a workflow, broadcast, or guide.
        module Type
          extend Knockapi::Internal::Type::Enum

          TaggedSymbol =
            T.type_alias { T.all(Symbol, Knockapi::Message::Source::Type) }
          OrSymbol = T.type_alias { T.any(Symbol, String) }

          BROADCAST =
            T.let(:broadcast, Knockapi::Message::Source::Type::TaggedSymbol)
          WORKFLOW =
            T.let(:workflow, Knockapi::Message::Source::Type::TaggedSymbol)
          GUIDE = T.let(:guide, Knockapi::Message::Source::Type::TaggedSymbol)

          sig do
            override.returns(
              T::Array[Knockapi::Message::Source::Type::TaggedSymbol]
            )
          end
          def self.values
          end
        end
      end

      # The message delivery status.
      module Status
        extend Knockapi::Internal::Type::Enum

        TaggedSymbol = T.type_alias { T.all(Symbol, Knockapi::Message::Status) }
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        QUEUED = T.let(:queued, Knockapi::Message::Status::TaggedSymbol)
        SENT = T.let(:sent, Knockapi::Message::Status::TaggedSymbol)
        DELIVERED = T.let(:delivered, Knockapi::Message::Status::TaggedSymbol)
        DELIVERY_ATTEMPTED =
          T.let(:delivery_attempted, Knockapi::Message::Status::TaggedSymbol)
        UNDELIVERED =
          T.let(:undelivered, Knockapi::Message::Status::TaggedSymbol)
        NOT_SENT = T.let(:not_sent, Knockapi::Message::Status::TaggedSymbol)
        BOUNCED = T.let(:bounced, Knockapi::Message::Status::TaggedSymbol)

        sig do
          override.returns(T::Array[Knockapi::Message::Status::TaggedSymbol])
        end
        def self.values
        end
      end

      class Channel < Knockapi::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(Knockapi::Message::Channel, Knockapi::Internal::AnyHash)
          end

        # The unique identifier for the channel.
        sig { returns(String) }
        attr_accessor :id

        # The timestamp of when the channel was created.
        sig { returns(Time) }
        attr_accessor :created_at

        # The ID of the provider that this channel uses to deliver messages.
        sig { returns(String) }
        attr_accessor :provider

        # The type of channel, determining what kind of messages it can send.
        sig { returns(Knockapi::Message::Channel::Type::TaggedSymbol) }
        attr_accessor :type

        # The timestamp of when the channel was last updated.
        sig { returns(Time) }
        attr_accessor :updated_at

        # Unique identifier for the channel within a project (immutable once created).
        sig { returns(T.nilable(String)) }
        attr_accessor :key

        # The human-readable name of the channel.
        sig { returns(T.nilable(String)) }
        attr_accessor :name

        # A configured channel, which is a way to route messages to a provider.
        sig do
          params(
            id: String,
            created_at: Time,
            provider: String,
            type: Knockapi::Message::Channel::Type::OrSymbol,
            updated_at: Time,
            key: T.nilable(String),
            name: T.nilable(String)
          ).returns(T.attached_class)
        end
        def self.new(
          # The unique identifier for the channel.
          id:,
          # The timestamp of when the channel was created.
          created_at:,
          # The ID of the provider that this channel uses to deliver messages.
          provider:,
          # The type of channel, determining what kind of messages it can send.
          type:,
          # The timestamp of when the channel was last updated.
          updated_at:,
          # Unique identifier for the channel within a project (immutable once created).
          key: nil,
          # The human-readable name of the channel.
          name: nil
        )
        end

        sig do
          override.returns(
            {
              id: String,
              created_at: Time,
              provider: String,
              type: Knockapi::Message::Channel::Type::TaggedSymbol,
              updated_at: Time,
              key: T.nilable(String),
              name: T.nilable(String)
            }
          )
        end
        def to_hash
        end

        # The type of channel, determining what kind of messages it can send.
        module Type
          extend Knockapi::Internal::Type::Enum

          TaggedSymbol =
            T.type_alias { T.all(Symbol, Knockapi::Message::Channel::Type) }
          OrSymbol = T.type_alias { T.any(Symbol, String) }

          EMAIL = T.let(:email, Knockapi::Message::Channel::Type::TaggedSymbol)
          IN_APP =
            T.let(:in_app, Knockapi::Message::Channel::Type::TaggedSymbol)
          IN_APP_FEED =
            T.let(:in_app_feed, Knockapi::Message::Channel::Type::TaggedSymbol)
          IN_APP_GUIDE =
            T.let(:in_app_guide, Knockapi::Message::Channel::Type::TaggedSymbol)
          SMS = T.let(:sms, Knockapi::Message::Channel::Type::TaggedSymbol)
          PUSH = T.let(:push, Knockapi::Message::Channel::Type::TaggedSymbol)
          CHAT = T.let(:chat, Knockapi::Message::Channel::Type::TaggedSymbol)
          HTTP = T.let(:http, Knockapi::Message::Channel::Type::TaggedSymbol)

          sig do
            override.returns(
              T::Array[Knockapi::Message::Channel::Type::TaggedSymbol]
            )
          end
          def self.values
          end
        end
      end
    end
  end
end

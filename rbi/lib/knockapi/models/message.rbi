# typed: strong

module Knockapi
  module Models
    class Message < Knockapi::BaseModel
      # The message ID
      sig { returns(T.nilable(String)) }
      attr_reader :id

      sig { params(id: String).void }
      attr_writer :id

      sig { returns(T.nilable(String)) }
      attr_reader :_typename

      sig { params(_typename: String).void }
      attr_writer :_typename

      # A list of actor representations associated with the message (up to 10)
      sig { returns(T.nilable(T::Array[T.any(String, Knockapi::Models::Message::Actor::ObjectReference)])) }
      attr_reader :actors

      sig do
        params(
          actors: T::Array[T.any(String, Knockapi::Models::Message::Actor::ObjectReference, Knockapi::Util::AnyHash)]
        )
          .void
      end
      attr_writer :actors

      # Timestamp when message was archived
      sig { returns(T.nilable(Time)) }
      attr_accessor :archived_at

      # Channel ID associated with the message
      sig { returns(T.nilable(String)) }
      attr_reader :channel_id

      sig { params(channel_id: String).void }
      attr_writer :channel_id

      # Timestamp when message was clicked
      sig { returns(T.nilable(Time)) }
      attr_accessor :clicked_at

      # Additional message data
      sig { returns(T.nilable(T::Hash[Symbol, T.anything])) }
      attr_accessor :data

      # List of engagement statuses
      sig { returns(T.nilable(T::Array[Knockapi::Models::Message::EngagementStatus::TaggedSymbol])) }
      attr_reader :engagement_statuses

      sig { params(engagement_statuses: T::Array[Knockapi::Models::Message::EngagementStatus::OrSymbol]).void }
      attr_writer :engagement_statuses

      # Timestamp of creation
      sig { returns(T.nilable(Time)) }
      attr_reader :inserted_at

      sig { params(inserted_at: Time).void }
      attr_writer :inserted_at

      # Timestamp when message was interacted with
      sig { returns(T.nilable(Time)) }
      attr_accessor :interacted_at

      # Timestamp when a link in the message was clicked
      sig { returns(T.nilable(Time)) }
      attr_accessor :link_clicked_at

      # Message metadata
      sig { returns(T.nilable(T::Hash[Symbol, T.anything])) }
      attr_accessor :metadata

      # Timestamp when message was read
      sig { returns(T.nilable(Time)) }
      attr_accessor :read_at

      # A reference to a recipient, either a user identifier (string) or an object
      #   reference (id, collection).
      sig { returns(T.nilable(T.any(String, Knockapi::Models::Message::Recipient::ObjectReference))) }
      attr_reader :recipient

      sig do
        params(
          recipient: T.any(String, Knockapi::Models::Message::Recipient::ObjectReference, Knockapi::Util::AnyHash)
        )
          .void
      end
      attr_writer :recipient

      # Timestamp when message was scheduled for
      sig { returns(T.nilable(Time)) }
      attr_accessor :scheduled_at

      # Timestamp when message was seen
      sig { returns(T.nilable(Time)) }
      attr_accessor :seen_at

      # Source information
      sig { returns(T.nilable(Knockapi::Models::Message::Source)) }
      attr_reader :source

      sig { params(source: T.any(Knockapi::Models::Message::Source, Knockapi::Util::AnyHash)).void }
      attr_writer :source

      # Message delivery status
      sig { returns(T.nilable(Knockapi::Models::Message::Status::TaggedSymbol)) }
      attr_reader :status

      sig { params(status: Knockapi::Models::Message::Status::OrSymbol).void }
      attr_writer :status

      # Tenant ID that the message belongs to
      sig { returns(T.nilable(String)) }
      attr_accessor :tenant

      # Timestamp of last update
      sig { returns(T.nilable(Time)) }
      attr_reader :updated_at

      sig { params(updated_at: Time).void }
      attr_writer :updated_at

      # Workflow key used to create the message
      sig { returns(T.nilable(String)) }
      attr_accessor :workflow

      # Represents a single message that was generated by a workflow for a given
      #   channel.
      sig do
        params(
          id: String,
          _typename: String,
          actors: T::Array[T.any(String, Knockapi::Models::Message::Actor::ObjectReference, Knockapi::Util::AnyHash)],
          archived_at: T.nilable(Time),
          channel_id: String,
          clicked_at: T.nilable(Time),
          data: T.nilable(T::Hash[Symbol, T.anything]),
          engagement_statuses: T::Array[Knockapi::Models::Message::EngagementStatus::OrSymbol],
          inserted_at: Time,
          interacted_at: T.nilable(Time),
          link_clicked_at: T.nilable(Time),
          metadata: T.nilable(T::Hash[Symbol, T.anything]),
          read_at: T.nilable(Time),
          recipient: T.any(String, Knockapi::Models::Message::Recipient::ObjectReference, Knockapi::Util::AnyHash),
          scheduled_at: T.nilable(Time),
          seen_at: T.nilable(Time),
          source: T.any(Knockapi::Models::Message::Source, Knockapi::Util::AnyHash),
          status: Knockapi::Models::Message::Status::OrSymbol,
          tenant: T.nilable(String),
          updated_at: Time,
          workflow: T.nilable(String)
        )
          .returns(T.attached_class)
      end
      def self.new(
        id: nil,
        _typename: nil,
        actors: nil,
        archived_at: nil,
        channel_id: nil,
        clicked_at: nil,
        data: nil,
        engagement_statuses: nil,
        inserted_at: nil,
        interacted_at: nil,
        link_clicked_at: nil,
        metadata: nil,
        read_at: nil,
        recipient: nil,
        scheduled_at: nil,
        seen_at: nil,
        source: nil,
        status: nil,
        tenant: nil,
        updated_at: nil,
        workflow: nil
      )
      end

      sig do
        override
          .returns(
            {
              id: String,
              _typename: String,
              actors: T::Array[T.any(String, Knockapi::Models::Message::Actor::ObjectReference)],
              archived_at: T.nilable(Time),
              channel_id: String,
              clicked_at: T.nilable(Time),
              data: T.nilable(T::Hash[Symbol, T.anything]),
              engagement_statuses: T::Array[Knockapi::Models::Message::EngagementStatus::TaggedSymbol],
              inserted_at: Time,
              interacted_at: T.nilable(Time),
              link_clicked_at: T.nilable(Time),
              metadata: T.nilable(T::Hash[Symbol, T.anything]),
              read_at: T.nilable(Time),
              recipient: T.any(String, Knockapi::Models::Message::Recipient::ObjectReference),
              scheduled_at: T.nilable(Time),
              seen_at: T.nilable(Time),
              source: Knockapi::Models::Message::Source,
              status: Knockapi::Models::Message::Status::TaggedSymbol,
              tenant: T.nilable(String),
              updated_at: Time,
              workflow: T.nilable(String)
            }
          )
      end
      def to_hash
      end

      # A reference to a recipient, either a user identifier (string) or an object
      #   reference (id, collection).
      module Actor
        extend Knockapi::Union

        class ObjectReference < Knockapi::BaseModel
          # An object identifier
          sig { returns(String) }
          attr_accessor :id

          # The collection the object belongs to
          sig { returns(String) }
          attr_accessor :collection

          # An object reference to a recipient
          sig { params(id: String, collection: String).returns(T.attached_class) }
          def self.new(id:, collection:)
          end

          sig { override.returns({id: String, collection: String}) }
          def to_hash
          end
        end

        sig { override.returns([String, Knockapi::Models::Message::Actor::ObjectReference]) }
        def self.variants
        end
      end

      module EngagementStatus
        extend Knockapi::Enum

        TaggedSymbol = T.type_alias { T.all(Symbol, Knockapi::Models::Message::EngagementStatus) }
        OrSymbol =
          T.type_alias { T.any(Symbol, String, Knockapi::Models::Message::EngagementStatus::TaggedSymbol) }

        SEEN = T.let(:seen, Knockapi::Models::Message::EngagementStatus::TaggedSymbol)
        READ = T.let(:read, Knockapi::Models::Message::EngagementStatus::TaggedSymbol)
        INTERACTED = T.let(:interacted, Knockapi::Models::Message::EngagementStatus::TaggedSymbol)
        LINK_CLICKED = T.let(:link_clicked, Knockapi::Models::Message::EngagementStatus::TaggedSymbol)
        ARCHIVED = T.let(:archived, Knockapi::Models::Message::EngagementStatus::TaggedSymbol)

        sig { override.returns(T::Array[Knockapi::Models::Message::EngagementStatus::TaggedSymbol]) }
        def self.values
        end
      end

      # A reference to a recipient, either a user identifier (string) or an object
      #   reference (id, collection).
      module Recipient
        extend Knockapi::Union

        class ObjectReference < Knockapi::BaseModel
          # An object identifier
          sig { returns(String) }
          attr_accessor :id

          # The collection the object belongs to
          sig { returns(String) }
          attr_accessor :collection

          # An object reference to a recipient
          sig { params(id: String, collection: String).returns(T.attached_class) }
          def self.new(id:, collection:)
          end

          sig { override.returns({id: String, collection: String}) }
          def to_hash
          end
        end

        sig { override.returns([String, Knockapi::Models::Message::Recipient::ObjectReference]) }
        def self.variants
        end
      end

      class Source < Knockapi::BaseModel
        sig { returns(String) }
        attr_accessor :_typename

        # The workflow categories
        sig { returns(T::Array[String]) }
        attr_accessor :categories

        # The workflow key
        sig { returns(String) }
        attr_accessor :key

        # The source version ID
        sig { returns(String) }
        attr_accessor :version_id

        # Source information
        sig do
          params(_typename: String, categories: T::Array[String], key: String, version_id: String)
            .returns(T.attached_class)
        end
        def self.new(_typename:, categories:, key:, version_id:)
        end

        sig do
          override.returns({_typename: String, categories: T::Array[String], key: String, version_id: String})
        end
        def to_hash
        end
      end

      # Message delivery status
      module Status
        extend Knockapi::Enum

        TaggedSymbol = T.type_alias { T.all(Symbol, Knockapi::Models::Message::Status) }
        OrSymbol = T.type_alias { T.any(Symbol, String, Knockapi::Models::Message::Status::TaggedSymbol) }

        QUEUED = T.let(:queued, Knockapi::Models::Message::Status::TaggedSymbol)
        SENT = T.let(:sent, Knockapi::Models::Message::Status::TaggedSymbol)
        DELIVERED = T.let(:delivered, Knockapi::Models::Message::Status::TaggedSymbol)
        DELIVERY_ATTEMPTED = T.let(:delivery_attempted, Knockapi::Models::Message::Status::TaggedSymbol)
        UNDELIVERED = T.let(:undelivered, Knockapi::Models::Message::Status::TaggedSymbol)
        NOT_SENT = T.let(:not_sent, Knockapi::Models::Message::Status::TaggedSymbol)
        BOUNCED = T.let(:bounced, Knockapi::Models::Message::Status::TaggedSymbol)

        sig { override.returns(T::Array[Knockapi::Models::Message::Status::TaggedSymbol]) }
        def self.values
        end
      end
    end
  end
end
